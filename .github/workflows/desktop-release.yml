name: Desktop Release Pipeline

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      channel:
        description: 'Release channel'
        required: true
        default: 'beta'
        type: choice
        options:
        - stable
        - beta
        - alpha
        - canary

env:
  VAULT_ADDR: ${{ secrets.VAULT_ADDR }}
  UPDATE_SERVICE_URL: ${{ secrets.UPDATE_SERVICE_URL }}

jobs:
  build:
    name: Build Desktop App
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-20.04
            platform: linux-x86_64
            ext: AppImage
          - os: ubuntu-20.04
            platform: linux-aarch64
            ext: AppImage
          - os: macos-latest
            platform: darwin-x86_64
            ext: dmg
          - os: macos-latest
            platform: darwin-aarch64
            ext: dmg
          - os: windows-latest
            platform: windows-x86_64
            ext: msi

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'

    - name: Setup Rust
      uses: dtolnay/rust-toolchain@stable

    - name: Install Linux dependencies
      if: matrix.os == 'ubuntu-20.04'
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          libwebkit2gtk-4.0-dev \
          build-essential \
          curl \
          wget \
          file \
          libssl-dev \
          libgtk-3-dev \
          libayatana-appindicator3-dev \
          librsvg2-dev

    - name: Install cross-compilation target (ARM64)
      if: matrix.platform == 'linux-aarch64' || matrix.platform == 'darwin-aarch64'
      run: |
        rustup target add aarch64-unknown-linux-gnu
        rustup target add aarch64-apple-darwin

    - name: Install dependencies
      run: npm ci

    - name: Build Tauri app
      env:
        TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
        TAURI_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}
      run: |
        if [ "${{ matrix.platform }}" = "linux-aarch64" ]; then
          npm run tauri build -- --target aarch64-unknown-linux-gnu
        elif [ "${{ matrix.platform }}" = "darwin-aarch64" ]; then
          npm run tauri build -- --target aarch64-apple-darwin
        else
          npm run tauri build
        fi

    - name: Prepare artifacts
      id: prepare
      run: |
        # Determine version
        if [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == refs/tags/* ]]; then
          VERSION=${GITHUB_REF#refs/tags/v}
          CHANNEL=stable
        else
          VERSION=$(node -p "require('./package.json').version")-$(git rev-parse --short HEAD)
          CHANNEL="${{ github.event.inputs.channel || 'beta' }}"
        fi
        
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "channel=$CHANNEL" >> $GITHUB_OUTPUT
        
        # Find built artifacts
        ARTIFACT_DIR="src-tauri/target"
        if [ "${{ matrix.platform }}" = "linux-aarch64" ]; then
          ARTIFACT_DIR="$ARTIFACT_DIR/aarch64-unknown-linux-gnu"
        elif [ "${{ matrix.platform }}" = "darwin-aarch64" ]; then
          ARTIFACT_DIR="$ARTIFACT_DIR/aarch64-apple-darwin"
        else
          ARTIFACT_DIR="$ARTIFACT_DIR/release"
        fi
        
        # Find the built file
        if [ "${{ matrix.ext }}" = "AppImage" ]; then
          ARTIFACT_PATH=$(find $ARTIFACT_DIR -name "*.AppImage" | head -1)
        elif [ "${{ matrix.ext }}" = "dmg" ]; then
          ARTIFACT_PATH=$(find $ARTIFACT_DIR -name "*.dmg" | head -1)
        elif [ "${{ matrix.ext }}" = "msi" ]; then
          ARTIFACT_PATH=$(find $ARTIFACT_DIR -name "*.msi" | head -1)
        fi
        
        echo "artifact_path=$ARTIFACT_PATH" >> $GITHUB_OUTPUT
        echo "artifact_name=santaclaude-${VERSION}-${{ matrix.platform }}.${{ matrix.ext }}" >> $GITHUB_OUTPUT

    - name: Upload artifact to GitHub
      uses: actions/upload-artifact@v4
      with:
        name: ${{ steps.prepare.outputs.artifact_name }}
        path: ${{ steps.prepare.outputs.artifact_path }}
        retention-days: 30

    - name: Upload to Update Service
      env:
        VERSION: ${{ steps.prepare.outputs.version }}
        CHANNEL: ${{ steps.prepare.outputs.channel }}
        PLATFORM: ${{ matrix.platform }}
        ARTIFACT_PATH: ${{ steps.prepare.outputs.artifact_path }}
        ARTIFACT_NAME: ${{ steps.prepare.outputs.artifact_name }}
      run: |
        # Generate release notes
        if [[ "$CHANNEL" == "stable" ]]; then
          RELEASE_NOTES=$(git tag -l --format='%(contents)' ${{ github.ref_name }} | head -500)
        else
          RELEASE_NOTES=$(git log --oneline -10 | head -500)
        fi
        
        # Upload to update service
        curl -X POST \
          -H "Authorization: Bearer ${{ secrets.UPDATE_SERVICE_TOKEN }}" \
          -F "file=@${ARTIFACT_PATH}" \
          -F "version=${VERSION}" \
          -F "channel=${CHANNEL}" \
          -F "platform=${PLATFORM}" \
          -F "release_notes=${RELEASE_NOTES}" \
          "${UPDATE_SERVICE_URL}/upload"

  promote:
    name: Promote Release
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && needs.build.result == 'success'
    environment: production

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Vault CLI
      uses: hashicorp/setup-vault@v2
      with:
        vault_version: 1.15.0

    - name: Authenticate with Vault
      run: |
        vault auth -method=github token=${{ secrets.GITHUB_TOKEN }}

    - name: Validate signing keys
      run: |
        # Check if signing keys are accessible
        vault kv get -field=public_key secret/desktop-updates/signing-key > /dev/null
        echo "âœ… Signing keys accessible"

    - name: Run smoke tests
      env:
        UPDATE_SERVICE_URL: ${{ secrets.UPDATE_SERVICE_URL }}
        UPDATE_SERVICE_TOKEN: ${{ secrets.UPDATE_SERVICE_TOKEN }}
      run: |
        # Test update service health
        curl -f "${UPDATE_SERVICE_URL}/health"
        echo "âœ… Update service healthy"
        
        # Test update manifests
        for channel in stable beta alpha; do
          curl -f "${UPDATE_SERVICE_URL}/manifest/${channel}"
          echo "âœ… $channel manifest accessible"
        done
        
        # Test public key endpoint
        curl -f "${UPDATE_SERVICE_URL}/public-key"
        echo "âœ… Public key accessible"

    - name: Canary deployment test
      env:
        UPDATE_SERVICE_URL: ${{ secrets.UPDATE_SERVICE_URL }}
      run: |
        # Test update check for each platform
        platforms=("linux-x86_64" "darwin-x86_64" "windows-x86_64")
        
        for platform in "${platforms[@]}"; do
          response=$(curl -s "${UPDATE_SERVICE_URL}/updates/beta/${platform}")
          echo "Update check for $platform: $response"
        done
        
        echo "âœ… Canary deployment validated"

    - name: Promote to stable channel
      if: startsWith(github.ref, 'refs/tags/')
      env:
        UPDATE_SERVICE_URL: ${{ secrets.UPDATE_SERVICE_URL }}
        UPDATE_SERVICE_TOKEN: ${{ secrets.UPDATE_SERVICE_TOKEN }}
        VERSION: ${{ steps.version.outputs.version }}
      run: |
        # This would typically move builds from beta to stable channel
        # For now, we log the promotion
        echo "ðŸš€ Promoting version $VERSION to stable channel"
        
        # In a real implementation, this might:
        # 1. Copy artifacts from beta to stable
        # 2. Update stable manifest
        # 3. Trigger CDN cache invalidation
        # 4. Send notifications

    - name: Notify release completion
      if: success()
      run: |
        echo "ðŸŽ‰ Desktop release pipeline completed successfully"
        echo "Version: ${{ steps.version.outputs.version }}"
        echo "Channel: ${{ steps.prepare.outputs.channel }}"
        echo "Platforms: All supported platforms built and deployed"

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: build

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Run security scan on artifacts
      run: |
        # This would typically run security scans on the built artifacts
        # For example: virus scanning, binary analysis, etc.
        echo "ðŸ”’ Running security scans..."
        
        # Placeholder for actual security scanning
        # In production, integrate with security scanning tools
        echo "âœ… Security scan completed"

    - name: Check dependencies for vulnerabilities
      run: |
        # Check npm dependencies
        npm audit --audit-level=high
        
        # Check Rust dependencies (if cargo-audit is available)
        # cargo audit
        
        echo "âœ… Dependency vulnerability scan completed"

  cleanup:
    name: Cleanup
    runs-on: ubuntu-latest
    needs: [build, promote, security-scan]
    if: always()

    steps:
    - name: Cleanup temporary artifacts
      run: |
        echo "ðŸ§¹ Cleaning up temporary artifacts and caches"
        # This would clean up any temporary files, caches, etc.
        # Left as placeholder since GitHub Actions handles most cleanup automatically